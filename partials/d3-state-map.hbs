<!--[if lte IE 9]><script>
(function(f){
window.setTimeout=f(window.setTimeout);
window.setInterval=f(window.setInterval);
})(function(f){return function(c,t){
var a=[].slice.call(arguments,2);return f(function(){c instanceof Function?c.apply(this,a):eval(c)},t)}
});
</script><![endif]-->
<script>
(function($, _) {

    // set up underscore template
    var sidebar_template = _.template($("#details_template").html());

    // helper function to sum a list of numbers
    var sum = function(ls) {
        return _.reduce(ls, function(memo, num){ return memo + num; }, 0);
    };

    // helper function to add intcommas
    // http://stackoverflow.com/a/2901298
    var intComma = function(x) {
        return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    };

    // cache DOM elements
    var $victim_total = $('#victim_total');
    var $timeline = $('#timeline');
    var $details = $('#details');
    var $playpause = $("#player-play-pause-button");
    var $previous = $("#player-previous-button");
    var $next = $("#player-next-button");
    var el = d3.select('#map');

    // set the aspect ratio for the map
    var aspect = 960 / 500;

    // set the width
    var width = el.node().getBoundingClientRect().width;

    // calculate the height
    var height = width / aspect;

    // set the projection
    var projection = d3.geo.albersUsa()
        .scale(width)
        .translate([width / 2, height / 2]);

    // and the path
    var path = d3.geo.path()
        .projection(projection);

    // and append the SVG
    var svg = el.append("svg")
        .attr("width", width)
        .attr("height", height);

    // load the data (async)
    d3_queue.queue()
        .defer(d3.json, '/data/us.json')
        .defer(d3.tsv, '/data/shooting-data.tsv')
    .await(ready);

    // main function to draw the map
    function ready(error, us, csv) {

        // a helper function to nab victim totals
        var get_victim_total = function(data) {
            var v_count = sum(
                _.map(
                    _.pluck(data, "fatalities"), function(d) {
                        return +d;
                    }
                ).concat(
                    _.map(
                        _.pluck(data, "wounded"), function(d) {
                            return +d;
                        }
                    )
                )
            );
            return v_count;
        };

        // populate the placeholder elements
        $("#incident_count").html(csv.length);
        $("#fatality_count").html(
            intComma(get_victim_total(csv))
        );

        // draw the U.S. shape
        svg.insert('path', '.graticule')
            .datum(topojson.feature(us, us.objects.land))
            .attr('class', 'land')
            .attr('d', path);

        // draw the state boundaries
        svg.insert('path', '.graticule')
            .datum(topojson.mesh(us, us.objects.states, function(a, b) { return a !== b; }))
            .attr('class', 'state-boundary')
            .attr('d', path);

        // get a unique list of years for the timeline
        var uniq_years = _.uniq(
            _.pluck(csv, "year")
        );

        // get min/max years
        var min_year = _.min(uniq_years);
        var max_year = _.max(uniq_years);

        // draw the baseline
        var bottom_line = [
            "<div class='bottomline'>",
            "<span class='pull-left'>",
            min_year,
            "</span>",
            "<span class='pull-right'>",
            max_year,
            "</span>",
             "</div>"].join("");

        // get the range of years to display
        var year_range = _.range(+min_year, +max_year+1);

        // set the bar width as a percentage
        var bar_width = 100 / year_range.length;

        // draw the timeline
        var timeline_string = '';
        _.each(year_range, function(d, i) {
            var incidents_this_year = _.filter(csv, function(x) {
                return +x.year === d;
            });

            // heighten up those bars
            var multiplier = 1.5;

            if (incidents_this_year.length > 0) {
                victim_count = get_victim_total(incidents_this_year);
            } else {
                victim_count = 0;
            }

            // make the bar chart
            timeline_string += "<div class='timeline-bar' id='" + d + "' style='height:" + (victim_count*multiplier) + "px; width:" + bar_width + "%;'></div>";
        });

        $timeline.html(timeline_string + "<div class='clearfix'></div>")
                 .append(bottom_line);

        // cache reference to DOM elements
        var $bars = $(".timeline-bar");

        // set the bubble size scale
        // scale (radius in px) = width / variable
        var scale = width / 1000;

        // function to draw bubbles on map
        function populate_map(year) {

            // reset bar colors to gray
            $bars.removeClass("timeline-bar-active");

            // ... except for the selected year
            $("#" + year).addClass("timeline-bar-active");

            // filter data to get shootings from the selected year
            var incidents_this_year = _.filter(csv, function(d) {
                return +d.year === +year;
            });

            // get victim total for the selected year
            victim_total_this_year = get_victim_total(incidents_this_year);

            // set default text for map when nothing is clicked on
            var default_text = "<h3 class='detail-hed'>Click on the bubble" + pluralize(incidents_this_year.length)[0] + " to show details about " + pluralize(incidents_this_year.length)[1] + " shooting.</h3>";

            // set (or reset) default text
            if (victim_total_this_year > 0) {
                $details.html(default_text);
            } else {
                $details.html('');
            }

            // populate the main hed
            $victim_total.html([
                year,
                ": ",
                victim_total_this_year,
                " victims"
            ].join(""));

            // wipe the map
            svg.selectAll("circle").remove();

            // draw the map bubbles
            svg.selectAll("circle")
                .data(incidents_this_year)
                .enter()
                .append("circle")
        		.attr("cx", function (d) { return projection([d.lng, d.lat])[0]; })
        		.attr("cy", function (d) { return projection([d.lng, d.lat])[1]; })
        		.attr("class", "dot")
                .attr("r",  function(d) { return (+d.fatalities + +d.wounded) * scale; })
                // click event
                .on("click", function(d) {
                    $details.html(sidebar_template(d));
                    svg.selectAll("circle")
                       .classed("dot", true)
                       .classed("highlighted", false);
                    d3.select(this).classed("highlighted", true);
                });
        }

        // handle resize
        d3.select(window)
            .on("resize", _.debounce(resize, 500));

        function resize() {
            var width = el.node().getBoundingClientRect().width;
            var height = width / aspect;

            // set the bubble size scale
            // scale (radius in px) = width / variable
            var scale = width / 1000;

            svg
                .attr('width', width)
                .attr('height', height);

            projection
                .scale(width)
                .translate([width / 2, height / 2]);

            d3.select('.state-boundary')
                .attr('d', path);

            d3.selectAll('.land')
                .attr('d', path);

            d3.selectAll('.dot')
        		.attr("cx", function (d) { return projection([d.lng, d.lat])[0]; })
        		.attr("cy", function (d) { return projection([d.lng, d.lat])[1]; })
                .attr("r",  function(d) { return (+d.fatalities + +d.wounded) * scale; });
        }

        // set up the timer for the play/pause/forward/back controls
        var timer;

        var cycle_through_data = function(current_year) {
            current_year = +current_year;
            populate_map(current_year);
            timer = window.setTimeout(function() {
                populate_map(current_year);
                if (current_year < max_year) {
                    current_year += 1;
                    cycle_through_data(current_year);
                } else {
                    cycle_through_data(min_year);
                }
            }, 1000);
        }

        // helper function to clear timer
        var clear_timer = function() {
            clearTimeout(timer);
            $playpause.find("i").removeClass("fa-pause").addClass("fa-play");
        }

        // helper functions to get current/next/previous years
        var get_current_year = function() {
            var active = $(".timeline-bar-active")[0];
            return +active.id;
        }

        var get_next_year = function() {
            var current = get_current_year();
            var next = current + 1;
            if (next > max_year) {
                next = min_year;
            }
            return +next;
        }

        var get_previous_year = function() {
            var current = get_current_year();
            var prev = current - 1;
            if (prev < min_year) {
                prev = max_year;
            }
            return +prev;
        }

        // set up click event for bars
        $bars.on("click", function() {
            clear_timer();
            var yr = this.id;
            populate_map(yr);
        });

        // set up click event for play/pause button
        $playpause.on('click', function(d) {
            var play_icon = $(this).find("i").hasClass("fa-play");
            var starting_year = get_current_year();
            if (play_icon) {
                // swap out icon
                $(this).find("i").removeClass("fa-play").addClass("fa-pause");

                // start playing
                cycle_through_data(starting_year);
            } else {
                // clear the timer
                clear_timer();
            }
        });

        // set up click events for forward/backward buttons
        $previous.on("click", function() {
            clear_timer();
            var previous = get_previous_year();
            populate_map(previous);
        });

        $next.on("click", function() {
            clear_timer();
            var next = get_next_year();
            populate_map(next);
        });

        // set initial view
        populate_map(max_year);

    } // end ready function
})(jQuery, _);
</script>
